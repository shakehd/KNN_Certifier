"""
This type stub file was generated by pyright.
"""

from typing import Callable, Optional
from concurrent.futures import Future
from pebble.common import PebbleFuture, ProcessFuture

class BasePool:
    def __init__(self, max_workers: int, max_tasks: int, initializer: Optional[Callable], initargs: list) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    
    @property
    def active(self) -> bool:
        ...
    
    def close(self): # -> None:
        """Closes the Pool preventing new tasks from being accepted.

        Pending tasks will be completed.
        """
        ...
    
    def stop(self): # -> None:
        """Stops the pool without performing any pending task."""
        ...
    
    def join(self, timeout: float = ...): # -> None:
        """Joins the pool waiting until all workers exited.

        If *timeout* is set, it block until all workers are done
        or raises TimeoutError.
        """
        ...
    


class PoolContext:
    def __init__(self, max_workers: int, max_tasks: int, initializer: Callable, initargs: list) -> None:
        ...
    
    @property
    def state(self) -> int:
        ...
    
    @state.setter
    def state(self, state: int): # -> None:
        ...
    
    @property
    def alive(self) -> bool:
        ...
    


class Task:
    def __init__(self, identifier: int, future: Future, timeout: Optional[float], payload: TaskPayload) -> None:
        ...
    
    @property
    def started(self) -> bool:
        ...
    
    def set_running_or_notify_cancel(self): # -> None:
        ...
    


class MapFuture(PebbleFuture):
    def __init__(self, futures: list) -> None:
        ...
    
    @property
    def futures(self) -> list:
        ...
    
    def cancel(self) -> bool:
        """Cancel the future.

        Returns True if any of the elements of the iterables is cancelled.
        False otherwise.
        """
        ...
    


class ProcessMapFuture(ProcessFuture):
    def __init__(self, futures: list) -> None:
        ...
    
    @property
    def futures(self) -> list:
        ...
    
    def cancel(self) -> bool:
        """Cancel the future.

        Returns True if any of the elements of the iterables is cancelled.
        False otherwise.
        """
        ...
    


class MapResults:
    def __init__(self, futures: list, timeout: float = ...) -> None:
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def next(self):
        ...
    
    __next__ = ...


def map_results(map_future: MapFuture, timeout: Optional[float]) -> MapFuture:
    ...

def iter_chunks(chunksize: int, *iterables): # -> Generator[tuple[Any, ...], Any, None]:
    """Iterates over zipped iterables in chunks."""
    ...

def chunk_result(future: ProcessFuture, timeout: Optional[float]): # -> tuple[BaseException]:
    """Returns the results of a processed chunk."""
    ...

def run_initializer(initializer: Callable, initargs: list): # -> bool:
    """Runs the Pool initializer dealing with errors."""
    ...

CREATED = ...
RUNNING = ...
CLOSED = ...
STOPPED = ...
ERROR = ...
Worker = ...
TaskPayload = ...

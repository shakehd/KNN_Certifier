"""
This type stub file was generated by pyright.
"""

from concurrent.futures import Future

class ProcessExpired(OSError):
    """Raised when process dies unexpectedly."""
    def __init__(self, msg, code=...) -> None:
        ...
    


class PebbleFuture(Future):
    def set_running_or_notify_cancel(self): # -> bool:
        """Mark the future as running or process any cancel notifications.

        Should only be used by Executor implementations and unit tests.

        If the future has been cancelled (cancel() was called and returned
        True) then any threads waiting on the future completing (though calls
        to as_completed() or wait()) are notified and False is returned.

        If the future was not cancelled then it is put in the running state
        (future calls to running() will return True) and True is returned.

        This method should be called by Executor implementations before
        executing the work associated with this future. If this method returns
        False then the work should not be executed.

        Returns:
            False if the Future was cancelled, True otherwise.

        Raises:
            RuntimeError: if set_result() or set_exception() was called.
        """
        ...
    


class ProcessFuture(PebbleFuture):
    def cancel(self): # -> bool:
        """Cancel the future.

        Returns True if the future was cancelled, False otherwise. A future
        cannot be cancelled if it has already completed.
        """
        ...
    


class RemoteTraceback(Exception):
    """Traceback wrapper for exceptions in remote process.

    Exception.__cause__ requires a BaseException subclass.

    """
    def __init__(self, traceback) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class RemoteException:
    """Pickling wrapper for exceptions in remote process."""
    def __init__(self, exception, traceback) -> None:
        ...
    
    def __reduce__(self): # -> tuple[Callable[..., Any], tuple[Any, Any]]:
        ...
    


def rebuild_exception(exception, traceback):
    ...

def launch_thread(name, function, daemon, *args, **kwargs): # -> Thread:
    ...

def launch_process(name, function, daemon, mp_context, *args, **kwargs):
    ...

def stop_process(process): # -> None:
    """Does its best to stop the process."""
    ...

def execute(function, *args, **kwargs): # -> Result:
    """Runs the given function returning its results or exception."""
    ...

def process_execute(function, *args, **kwargs): # -> Result:
    """Runs the given function returning its results or exception."""
    ...

def send_result(pipe, data): # -> None:
    """Send result handling pickling and communication errors."""
    ...

Result = ...
SUCCESS = ...
FAILURE = ...
ERROR = ...
SLEEP_UNIT = ...
PENDING = ...
RUNNING = ...
FINISHED = ...
CANCELLED = ...
CANCELLED_AND_NOTIFIED = ...
